package science.example.week6coroutines

import androidx.appcompat.app.AppCompatActivity
import android.os.Bundle
import androidx.fragment.app.Fragment

class MainActivity : AppCompatActivity() {

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        val openFragment = this.supportFragmentManager.beginTransaction()
        openFragment.replace(R.id.fragment1, Fragment1.newInstance())
        openFragment.commit()
        val openFragment2 = this.supportFragmentManager.beginTransaction()
        openFragment2.replace(R.id.fragment2, Fragment2.newInstance())
        openFragment2.commit()
    }

}



//                  Преимущество использования корутин:
//                          *Эффективность*
//Многозадачная программа эффективнее расходует ресурсы. Основной код не блокируется,
//чтобы мог выполниться вспмогательный модуль. Вместо этого они работают асинхронно.
//                       *Удобство использования*
//Корутины выполняются быстро, для пользователя это выглядит как одновременное
//выполнение задач. Ему не приходится долго ждать ответа программы. Он продолжает
//работу с ней, пока асинхронные корутины незаменто для него выполняют доп.действия.
//                     *Снижение нагрузки на систему*
//Асинхронность позволяет выполнять несколько действий в рамках одного потока,
//вместо того, чтобы множить потоки. Системе проще восприимать 1 поток, чем несколько.
//                          *Гибкость управления*
//Переключение между корутинами происходит вручную. Программист сам прописывает этот метод
//в коде. Поэтому управление корутинами можно контроллировать, что дает разработчику
//больше возможностей. Нет риска, что программа переключится между блоками кода в
//неподходящий момент, как это бывает с менее гибкими решениями.


//                                      Недостатки:
//                          *Сложность и высокий порог вхождения*
//Разобраться в работе корутин и писать асинхронный код может быть сложно.
//                                  *Узкая специализация*
//Корутины - высокоуровневое решение. Ускорить сложные вычисления с помощью сопрограмм не получится.
//В этом случае нужна многопоточность, а не асинхронность. При этом корутины подходят
//для снижения нагрузки на систему.
//                                  *Отсутствие в ряде языков*


//Разберем как устроены корутины на нашем примере
//                val job: Job = GlobalScope.launch(Dispatchers.IO) {
//                            Pi()
//                        }


//Pi() — метод, который нам нужно выполнить асинхронно.

//GlobalScope — жизненные рамки для корутины. В данном случае корутина будет жить, пока живо приложение,
// в котором она запущена. GlobalScope — конкретная реализация интерфейса CoroutineScope.
// Можно реализовать свой scope, например, в Activity, и это приведет к тому, что запущенные в Activity
// корутины будут автоматически отменяться в случае завершения или краша Activity.

//launch — метод для асинхронного запуска корутины. Соответственно, метод Pi() запустится сразу же.
// Метод возвращает экземпляр класса Job. Этот объект можно использовать для того, чтобы, например,
// отменить корутину — job.cancel(). Альтернатива — метод asunc(). Он вернет Deferred<T> — отложенную корутину,
// которую можно запустить позднее.

//Dispatchers.IO — один из параметров метода launch(). Здесь указывается диспетчер для созданной корутины.
// Конкретно диспетчер Dispatchers.IO используется для фоновых задач, не блокирующих основной поток.
// Если указать Dispatchers.Main, то корутина будет выполняться в основном потоке.